var radiansToDegrees = function(radians) { return radians*180/Math.PI };
var degreesToRadians = function(degrees) { return Math.PI/180*degrees };

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
window.requestAnimationFrame = (function()
{
	return window.requestAnimationFrame      || 
	      window.webkitRequestAnimationFrame || 
	      window.mozRequestAnimationFrame    || 
	      window.oRequestAnimationFrame      || 
	      window.msRequestAnimationFrame     || 
	      
	      function(callback) {
          window.setTimeout(callback, 1000 / 60);
	      };
})();

window.delegate = function(object, method) {
	return function() { 
		return method.apply(object, arguments);
	};
};

window.getVendorPrefix = function() {
  var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;
  var someScript = document.getElementsByTagName('script')[0];

  for(var prop in someScript.style) {
    if(regex.test(prop)) {
      // test is faster than match, so it's better to perform
      // that on the lot and match only when necessary
      return prop.match(regex)[0];
    }
  }

  // Nothing found so far? Webkit does not enumerate over the CSS properties of the style object.
  // However (prop in style) returns the correct value, so we'll have to test for
  // the precence of a specific property
  if('WebkitOpacity' in someScript.style) return 'Webkit';
  if('KhtmlOpacity' in someScript.style) return 'Khtml';

  return '';
};

(function() {
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;
  // The base Class implementation (does nothing)
  this.Class = function(){};
  
  // Create a new Class that inherits from this class
  Class.extend = function(prop) {
    var _super = this.prototype;
    
    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;
    
    // Copy the properties over onto the new prototype
    for (var name in prop) {
      // Check if we're overwriting an existing function
      prototype[name] = typeof prop[name] == "function" && 
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;
            
            // Add a new ._super() method that is the same method
            // but on the super-class
            this._super = _super[name];
            
            // The method only need to be bound temporarily, so we
            // remove it when we're done executing
            var ret = fn.apply(this, arguments);        
            this._super = tmp;
            
            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
    
    // The dummy class constructor
    function Class() {
      // All construction is actually done in the init method
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }
    
    // Populate our constructed prototype object
    Class.prototype = prototype;
    
    // Enforce the constructor to be what we expect
    Class.prototype.constructor = Class;

    // And make this class extendable
    Class.extend = arguments.callee;
    
    return Class;
  };
})();

/* **********************************************
     Begin r88.event.dispatcher.js
********************************************** */

var EventDispatcher = Class.extend({

	init: function(name) {
		this._events = {};
	},

	addListener: function(event, listener) {
		if(!event) {
			console.assert(!Rocket88.showErrors, "Required parameter 'event' is missing");		
			return;
		}

		if(!listener) {
			console.assert(!Rocket88.showErrors, "Required parameter 'listener' is missing");		
			return;
		}

    	var myEvents = this._events;
        var myListeners = myEvents[event] = myEvents[event] || [];

      	myListeners.push(listener);
  	},

	removeListener: function(event, listener) {
    	var myListeners = this._events[event];

    	var i = myListeners.length;
    	while(--i > -1) {
    		var myListener = myListeners[i];
    		if(myListeners==listener) {
    			myListeners.splice(i, 1);
    		}
    	}
  	},  	

  	removeAllListeners: function() {
  		this._events = {};
  	},

	dispatch: function(event) {
		var myListeners = this._events[event];
		if(myListeners) {
			var myArgs = Array.prototype.slice.call(arguments, 1);
			for (var i = 0, l = myListeners.length; i < l; i++) {
				var myListener = myListeners[i];
		  		myListener.apply(null, myArgs);
			}			
		}
	},

	// Destroys the object
	dispose: function() {       
		this._events = null;
    },
});

/* **********************************************
     Begin r88.linked.list.js
********************************************** */

var LinkedList = Class.extend({

	init: function() {

		// Private properties
		this._head = null;
		this._tail = null;
		this._size = 0;

		// Getters/setters
		this.__defineGetter__("head", function(){ return this._head});
		this.__defineGetter__("tail", function(){ return this._tail});		
		this.__defineGetter__("size", function(){ return this._size});
	},
		
	add: function(data) {
		// Adds node with data to the list
		this._size++;	

		var myNode = new LinkedListNode(data, this);
		if (this._head)  {
			myNode.prev = this._tail;
			this._tail.next = myNode;
			this._tail = myNode;
		}
		else {
			this._head = myNode;
			this._tail = myNode;
		}
		
		return myNode;
	},
	
	insertBefore: function(data, node) {
		// Inserts a node before another one
		this._size++;
		
		var myNode = new LinkedListNode(data, this);
		if (node==this._head) {
			myNode.next = this._head;
			this._head.prev = myNode;
			this._head = myNode;
			
			return myNode;
		}
		
		// Search for the node
		var myPreviousNode = node.prev;
		
		myPreviousNode.next = myNode;
		node.prev = myNode;
		
		myNode.prev = myPreviousNode;
		myNode.next = node;
		
		return myNode;
	},
	
	insertAfter: function(data, node) {
		// Inserts a node 
		this._size++;
		
		var myNode = new LinkedListNode(data, this);
		if (node==this._tail) {
			this._tail.next = myNode;
			this._tail = myNode;
			
			return myNode;
		}

		myNode.next = node.next;
		myNode.prev = node;
		
		node.next = myNode;
		
		return myNode;
	},	
	
	remove: function(node) {
		// Removes a node from the list
		if (node==this._head) {
			this.shift();			
			return true;
		}
		
		// Remove tail
		else if(node==this._tail) {
			this.pop();
			return true;
		}
			
		// Search for the node
		var myNext = node.next;
		var myPrev = node.prev;
		
		myNext.prev = myPrev;
		myPrev.next = myNext;		
		
		this._size--;
		node.dispose();

		return node;
	},
	
	shift: function() {
		// Removes the first node from the list
		if (this._head) {
			this._size--;
			if (this._head == this._tail) {
				this._head = null;
				this._tail = null;
			}
			else {
				var myNode = this._head.next;
				myNode.prev = null;
				this._head = myNode;
			}
		}
		
		return this._head;
	},
			
	pop: function()
	{
		// Removes the last node from the list
		if (this._tail) {
			this._size--;
			if (this._head == this._tail) {
				this._head = null;
				this._tail = null;
			}
			else {
				var myNode = this._tail.prev;
				myNode.next = null;
				this._tail = myNode;
			}
		}
		
		return this._tail;
	},
		
	swap: function(nodeA, nodeB) {
		var myDataA = nodeA.data;
		nodeA.data = nodeB.data;
		nodeB.data = myDataA;
	},

    sort: function(property) {
        var myNode = this._extensionList.head();
        while (myNode) {
            var myExtension = myNode.data;

            // Destroy the extension
            if(myExtension.autoDestroy()) {
                myExtension.destroy();
            }

            myNode = myNode.next;
        }
    },

	// Returns a boolean indication if a node exists for data	
	contains: function(data)
	{
		var myNode = this._head;
		while (myNode) {
			if (myNode.data == data) {
				return true;
			}
			
			myNode = myNode.next;
		}
		
		return false;
	},
			
	empty: function() {
		var myNode = this.head;
		while (myNode) {
			var myNextNode = myNode.next;
			this.remove(myNode);
			myNode = myNextNode;
		}
	},

	nodeOf: function(data)
	{
		var myNode = this._head
		while (myNode) {
			if (myNode.data == data) {
				return myNode;
			}
				
			myNode = myNode.next;
		}
		
		return null;
	},
	
	toArray: function() {
		var myArray = [];
		
		var myNode = this._head;
		while (myNode) {
			myArray.push(myNode.data);
			myNode = myNode.next;
		}
		
		return myArray;
	},

	empty: function() {

	}
});


var LinkedListNode = Class.extend({

	init: function(data, list) {

		// Private proeprties
		this._list = list;
		
		// Public properties
		this.data = data;
		this.next = null;
		this.prev = null;

		// Getters/setters
		this.__defineGetter__("list", function() { return this._list });
	},
		
	
	// Removes the node from its parent list
	remove: function() {
		this._list.remove(this);
	},

	dispose: function () {
		this._list = null;

		this.data = null;
		this.next = null;
		this.prev = null;
	}
});

/* **********************************************
     Begin r88.object.pool.js
********************************************** */



/* **********************************************
     Begin r88.asset.loader.js
********************************************** */

var AssetLoader = Class.extend({

	init: function() {
		this._queue = new Array();

		this._currentIndex = 0;
		this._running = false;

		this._imageExtensions = ["png","jpg","jpeg","gif"];
		this._textExtensions = ["txt", "xml", "json", "php"];

		this._assetStore = AssetStore.getInstance();
	},

	addAsset: function(url) {
		this._queue.push(url);
	},

	addAssets: function(assets) {
		this._queue = this._queue.concat(assets);
	},

	downloadAssets: function(totalSize) {
		if(this._running) {
			return;
		}

		this._running = true;
		this._currentIndex = -1;

		this.downloadNext();
	},

	downloadNext: function() {
		this._currentIndex++;
		var myURL = this._queue[this._currentIndex];

		var myExtension = myURL.split(".").pop();
		if(this._imageExtensions.indexOf(myExtension)>-1) {
			this.downloadImage(myURL);
		}
		else if (this._textExtensions.indexOf(myExtension)>-1) {
			this.downloadTextFile(myURL);
		}
	},

	downloadImage: function(url) {
		var self = this;
		var myImage = new Image();

		myImage.onprogress = function(event) {
			console.log(event);
		}

		myImage.onload = function (event) {
			self._assetStore.addAsset(this, url);
			self.downloadNext();
		}

		myImage.src = url;
	},

	downloadTextFile: function(url) {
		var self = this;
		var myXHR = new XMLHttpRequest();

		myXHR.onprogress = function(event) {
			console.log(event);
		}

		myXHR.onreadystatechange=function(event) {
			if (myXHR.readyState==4 && myXHR.status==200) {
				self._assetStore.addAsset(this, url);
			}
		}

		myXHR.open("GET", url, true);
		myXHR.send();
	},

	dispose: function() {
		this._super();
		this._assetStore = null;
	}
});

AssetLoader.getInstance = function() {
	var myInstance = AssetLoader.instance;
	if(myInstance==undefined) {
		myInstance = new AssetLoader();
	}

	return myInstance;
}


/* **********************************************
     Begin r88.asset.store.js
********************************************** */

var AssetStore = Class.extend({

	init: function() {
		if(AssetStore.instance) {
			throw ReferenceError("Houston, we have a problem. AssetStore is a singleton class. Use the static getInstance() method to get a reference.");
		}

		AssetStore.instance = this;

		// Private properties
		this._disposed = false;
		this._assets = new Object();

		// Getters
		this.__defineGetter__("isDisposed", function() { return this._disposed; });
		this.__defineGetter__("assets", function() { 
			var myAssets = new Array();
			for (var path in this._assets) {
				myAssets.push(path);
			}

			return myAssets; 
		});
	},

	addAsset: function(asset, path) {
		if(this.hasAsset(path)) {
			console.error("Unable to add asset: " + path + " to AssetStore. Asset already exists.");
			return;
		}

		if(!asset) {
			console.error("Unable to add asset: " + path + " to AssetStore. Asset cannot be undefined.");
			return;			
		}

		this._assets[path] = asset;
	},

	removeAllAssets: function() {
		for (var path in this._assets) {
			delete this._assets[path];
		}

		this._assets = new Object();
	},

	assetForPath: function(path) {
		return this._assets[path];
	},

	assetType: function(path) {
		return path.split(".").pop();
	},

	hasAsset: function(path) {
		return this._assets[path] != null;
	},

	dispose: function() {
        if(this._disposed) {
        	console.error("Unable to dispose object: " + this.name);	
        }

		console.info(this.type + ": " + this.name + " is disposed");	
	
		this.removeAllAssets();
		
		this._disposed = true;		
		this._assets = null;
	}
});

AssetStore.getInstance = function() {
	var myInstance = AssetStore.instance;
	if(myInstance==undefined) {
		myInstance = new AssetStore();
	}

	return myInstance;
}

/* **********************************************
     Begin r88.collision.solver.js
********************************************** */

var b2ContactListener = Box2D.Dynamics.b2ContactListener,
	b2WorldManifold = Box2D.Collision.b2WorldManifold;

var CollisionSolver = Class.extend({ 
	init: function() {

		this._collisions = null;
		this._listener = new b2ContactListener();

		this._listener.BeginContact = delegate(this, this.beginContact);
		this._listener.EndContact = delegate(this, this.endContact);

		this._listener.PreSolve = delegate(this, this.preSolve);
		this._listener.PostSolve = delegate(this, this.postSolve);

		this.__defineGetter__("listener", function() { return this._listener; });
	},

	prepare: function() {
		this._collisions = new Object();
	},

	beginContact: function(contact) {
		var myName = this.getContactName(contact),
			myCollision = this._collisions[myName];

		if(myCollision==undefined) {
			var myGameObjectA = contact.GetFixtureA().GetUserData(),
				myGameObjectB = contact.GetFixtureB().GetUserData();

			myCollision = [myGameObjectA, myGameObjectB];;
			this._collisions[myName] = myCollision;

			if(myGameObjectA.collision.enabled) {
				myGameObjectA.collision.beginContact(myGameObjectB);
			}

			if(myGameObjectB.collision.enabled) {
				myGameObjectB.collision.beginContact(myGameObjectA);
			}
		}
	},

	endContact: function(contact) {
		var myGameObjectA = contact.GetFixtureA().GetUserData(),
			myGameObjectB = contact.GetFixtureB().GetUserData();

		if(myGameObjectA.collision.enabled) {
			myGameObjectA.collision.endContact(myGameObjectB);
		}

		if(myGameObjectB.collision.enabled) {
			myGameObjectB.collision.endContact(myGameObjectA);
		}
	},
	
	preSolve: function(contact, manifold) {
		var myName = this.getContactName(contact),
			myCollision = this._collisions[myName];
		
		if(myCollision) {
			var manifold = new b2WorldManifold();
			contact.GetWorldManifold(manifold);

			var myPosition = manifold.m_points[0];
			myCollision.position = new Point(myPosition.x * 30, myPosition.y * 30);
		}		
	},

	postSolve: function(contact, impulse) {
		var myName = this.getContactName(contact),
			myCollision = this._collisions[myName];
		
		if(myCollision) {
			myCollision.impact = impulse.normalImpulses[0];
		}		
	},

	finish: function() {
		for(var name in this._collisions) {
			var myCollision = this._collisions[name],
				myGameObjectA = myCollision[0],
				myGameObjectB = myCollision[1];

			if(myGameObjectA.collision.enabled) {
				myGameObjectA.collision.onCollision(myGameObjectB, myCollision.position, myCollision.impact);
			}

			if(myGameObjectB.collision.enabled) {
				myGameObjectB.collision.onCollision(myGameObjectA, myCollision.position, myCollision.impact);
			}			
		}

		this._collisions = null;
	},

	getContactName: function(contact) {
		var myGameObjectA = contact.GetFixtureA().GetUserData(),
			myGameObjectB = contact.GetFixtureB().GetUserData();

		return myGameObjectA.name + ".vs." + myGameObjectB.name;
	},

	dispose: function() {
		this._collisions = null;
		this._listener = null;
	}
});

/* **********************************************
     Begin r88.matrix.js
********************************************** */

var Matrix = Class.extend({

	// inheritDoc
	init: function(a, b, c, d, tx, ty) {
		this.a = a || 1;
		this.b = b || 0;
		this.c = c || 0;
		this.d = d || 1;

		this.tx = tx || 0;
		this.ty = ty || 0;
	},
	
	identity: function() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;

		this.tx = 0;
		this.ty = 0;

		return this;
	},
	
	inverse: function() {
 		var determinant = this.a * this.d - this.b * this.c;

		var myA = this.d / determinant;
        var myB = -1 * this.b / determinant;
		var myC = -1 * this.c / determinant;
		var myD = this.a / determinant;
		var myTx = (this.c * this.ty - this.d * this.tx) / determinant;
		var myTy = (this.b * this.tx - this.a * this.ty) / determinant;

		this.a = myA;
		this.b = myB;
		this.c = myC;
		this.d = myD;
		this.tx = myTx;
		this.ty = myTy;

		return this;
	},

	multiply: function(matrix) {
		var myA = this.a * matrix.a + this.c * matrix.b;
        var myB = this.b * matrix.a + this.d * matrix.b;
		var myC = this.a * matrix.c + this.c * matrix.d;
		var myD = this.b * matrix.c + this.d * matrix.d;
		var myTx = this.a * matrix.tx + this.c * matrix.ty + this.tx;
		var myTy = this.b * matrix.tx + this.d * matrix.ty + this.ty;

		this.a = myA;
		this.b = myB;
		this.c = myC;
		this.d = myD;
		this.tx = myTx;
		this.ty = myTy;

		return this;		
	},

	translate: function(x, y) {
		// Create translation matrix
		var myMatrix = new Matrix(1, 0, 0, 1, x, y);		
		this.multiply(myMatrix);

		return this;		
	},
	
	rotate: function(radians) {
		var mySine 		= Math.sin(radians);
		var myCosine 	= Math.cos(radians);

		// Create rotation matrix
		var myMatrix = new Matrix(myCosine, mySine, -1 * mySine, myCosine);	
		this.multiply(myMatrix);

		return this;
	},
	
	scale: function(x, y) {
		// Create scale matrix
		var myMatrix = new Matrix(x, 0, 0, y);
		this.multiply(myMatrix);

		return this;
	},

	clone: function() {
		return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
	},

	toString: function() {
		return "[matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
	},

	toCss: function() {
		var myMatrix = "matrix(" + this.a.toFixed(12) + "," + this.b.toFixed(12) + "," + this.c.toFixed(12) + "," + this.d.toFixed(12) + "," + this.tx.toFixed(12) + "," + this.ty.toFixed(12) + ")";
		var myCSS = "-moz-transform:" + myMatrix + ";-webkit-transform:" + myMatrix + ";-o-transform:" + myMatrix + ";transform:" + myMatrix + ";";

		return myCSS;
	}
});

/* **********************************************
     Begin r88.point.js
********************************************** */

var b2Vec2 = Box2D.Common.Math.b2Vec2;

var Point = Class.extend({

	init: function(x, y) {
		this.x = x || 0;
		this.y = y || 0;
	},
	
	add: function(point) {
		this.x += point.x();
		this.y += point.y();
	},

	substract: function(point) {
		this.x -= point.x();
		this.y -= point.y();
	},

	multiply: function(value) {
		this.x *= value;
		this.y *= value;
	},

	distanceTo: function(point) {
		var myX = point.x() - this.x;
		var myY = point.y() - this.y;

		return Math.sqrt((myX * myX) + (myY * myY));
	},

	direction: function() {
		var myX = point.x() - this.x;
		var myY = point.y() - this.y;

   		return Math.atan2(myY, myX);
	},
	
	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		return "[point x=" + this.x + " y=" + this.y + "]";
	},

	toCss: function() {
		return "left:" + this.x.toFixed(12) +";top:" + this.y.toFixed(12) + ";";
	},

	toB2Vec2: function() {
		var myScale = 1 / 30;
		return new b2Vec2(this.x * myScale, this.y * myScale);
	}
});

/* **********************************************
     Begin r88.rectangle.js
********************************************** */

var Rectangle = Class.extend({

	init: function(x, y, width, height) {

		// Public properties
		this.origin 	= new Point(x, y);
		this.size 		= new Size(width, height);

		// Getters/setters
		this.__defineGetter__("top", function() { return this.origin.y });
		this.__defineGetter__("right", function() { return this.origin.x + this.size.width });
		this.__defineGetter__("bottom", function() { return this.origin.y + this.size.height });
		this.__defineGetter__("left", function() { return this.origin.x });
		this.__defineGetter__("isEmpty", function() { return this.size.isEmpty });
	},
	
	center: function() {
		this.origin.x(-0.5 * this.size.width());
		this.origin.y(-0.5 * this.size.height());		
	},

	contains: function(point) {
		var myHorizontal = point.x() > this.left() && point.x() < this.right();
		var myVertical	 = point.y() > this.top() && point.y() < this.bottom();

		return myHorizontal && myVertical;
	},

	inflate: function(size) {
		this.origin.x(this.origin.x() - size.width());
		this.size.width(this.size.width() + size.width() * 2);

		this.origin.y(this.origin.y() - size.height());
		this.size.height(this.size.height() + size.height() * 2);
	},

	deflate: function(size) {
		this.origin.x(this.origin.x() + size.width());
		this.size.width(this.size.width() - size.width() * 2);

		this.origin.y(this.origin.y() + size.height());
		this.size.height(this.size.height() - size.height() * 2);
	},

	empty: function() {
		this.origin.x = 0;
		this.origin.y = 0;
		this.size.empty();
	},

	clone: function() {
		return new Rectangle(this.origin.x, this.origin.y, this.size.width, this.size.height);
	},

	toString: function() {
		return "[rectangle x=" + this.origin.x + " y=" + this.origin.y + " width=" + this.size.width + " height=" + this.size.height + "]";
	},

	toCss: function() {
		return this.origin.toCss() + this.size.toCss();
	}
});

/* **********************************************
     Begin r88.size.js
********************************************** */

var Size = Class.extend({

	init: function(width, height) {
		this.width = width || 0;
		this.height = height || 0;

		this.__defineGetter__("isEmpty", function() { return this.width==0 && this.height==0; })
	},

	empty: function() {
		this.width = 0;
		this.height = 0;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		return "[size width=" + this.width + " height=" + this.height + "]";
	},

	toCss: function () {
		return "width:" + this.width.toFixed(12) + ";height:" + this.height.toFixed(12) + ";";
	}
});

/* **********************************************
     Begin r88.rotation.js
********************************************** */

var Rotation = Class.extend({

	init: function(x, y) {
		// Private properties
		this._degrees = 0;
		this._radians = 0;

		// Getters/setters
		this.__defineGetter__("degrees", function() { return this._degrees; });
		this.__defineSetter__("degrees", function(degrees) {
			this._degrees = degrees;
			this._radians = degreesToRadians(degrees);
		});

		this.__defineGetter__("radians", function() { return this._radians; });
		this.__defineSetter__("radians", function(radians) { 
			this._radians = radians;
			this._degrees = radiansToDegrees(radians);
		});
	}
});

/* **********************************************
     Begin r88.object88.js
********************************************** */

var Object88 = EventDispatcher.extend({

	// Executes when the object is instantiated
	init: function(name) {
		this._super();

		// Private properties
		this._createdAt 	= new Date().getTime();
		this._name 			= name || "unnamed" + Math.round((Math.random() * this._createdAt));
		this._ready 		= false;
		this._disposed	 	= false;

		this._director		= Director.getInstance();
		this._assetStore	= AssetStore.getInstance();
		this._assetLoader	= AssetLoader.getInstance();

		// Public properties
		this.autoDispose 	= true;
		this.tag			= 0;

	    // Getters
	    this.__defineGetter__("type", function() { return "Object88"; });
	    this.__defineGetter__("name", function() { return this._name; });
	    this.__defineGetter__("createdAt", function() { return this._createdAt; });
	    this.__defineGetter__("isReady", function() { return this._ready; });
	    this.__defineGetter__("isDisposed", function() { return this._disposed; });

	   	this.__defineGetter__("director", function() { return this._director });
	    this.__defineGetter__("assetStore", function() { return this._assetStore });	   	
	},

	// All properties are injected and set and the game is ready to run.
	ready: function() {
		this._ready = true;

		console.info(this.type + ": " + this._name + " is ready");	

		this.dispatch("ready", this);
	},
	
	// Executes every render tick
	update: function() {	
		if(!this._ready) {
			return;
		}
	},
	
	// Clones the object
	clone: function(name) {
		var myClone = new Object88(name);
		return myClone;
	},

	// String representation of the object
	toString: function() {
		return "[" + this.type + " name=\"" + this._name + "\" isReady=" + this._ready + " isDisposed=" + this._disposed	 + "]";
	},

	// Destroys the object
	dispose: function() {
		this._super();
		
        if(this._disposed) {
        	console.assert(!Rocket88.showErrors, "Unable to dispose object: " + this.name);	
        }

		this.dispatch("disposed", this);
		console.info(this.type + ": " + this._name + " is disposed");	
		
		this._assetStore = null;	
		this._director = null;
		this._name = null;
        this._world = null;
        this._disposed = true;
    },
});

/* **********************************************
     Begin r88.director.js
********************************************** */

var Director = Class.extend({

	// Executes when the object is instantiated
	init: function(debugMode) {		
		if(Director.instance) {
			throw ReferenceError("Houston, we have a problem. Director is a singleton class. Use the static getInstance() method to get a reference.");
		}

		Director.instance = this;

		// Author information
		this.version = "0.1",
		this.authors = "Patrick Pietens"

		console.log("This game utilises the Rocket88 engine v" + this.version);

		if(debugMode) {
			this._stats = new Stats();
			this._stats.domElement.style.position = "absolute";
			this._stats.domElement.style.top = "0px";
			this._stats.domElement.style.left = "0px";
			
			document.body.appendChild(this._stats.domElement);			
		}

		// Private properties
		this._accumulator 	= 0;
		this._crashed		= false;
		this._currentScene 	= null;
		this._currentTime 	= new Date().getTime();
		this._frame 		= 0;
		this._frameTime 	= 1000 / 60;
		this._paused 		= false;
		this._renderer 		= undefined;		

		// Public properties
		this.debugMode	 	= debugMode;
		this.showWarnings 	= debugMode;
		this.showErrors	 	= debugMode;

	    // Getters/setters
		this.__defineGetter__("type", function(){ return "Rocket88" });
		this.__defineGetter__("assetStore", function(){ return this._assetStore });
		this.__defineGetter__("crashed", function(){ return this._crashed });

		// Setters
		this.__defineGetter__("renderer", function(){ return this._renderer });		
		this.__defineSetter__("renderer", function(renderer) {
			if(this._renderer) {
				console.assert(!this.showErrors, "Renderer already added");
			}
			
			this._renderer = renderer;
		});

		this.__defineGetter__("scene", function(){ return this._currentScene });
		this.__defineSetter__("scene", function(scene) {
			
			// Destroy previous scene
			if(this._currentScene && this._currentScene.autoDestroy) {
				this._currentScene.destroy();
			}
			
			// Set the scene
			this._currentScene = scene;
		});
	},
		
	// Updates the scene using a fixed timestep
	updateWithFixedTimestep: function() {	
		if (!this._paused && !this._crashed) {		
			requestAnimationFrame(delegate(this, this.updateWithFixedTimestep));

			// Set local properties
			var myNow = new Date().getTime();
			var myTimestep = myNow - this._currentTime;

			// Update the time & accumulator
			this._accumulator += myTimestep;
			this._currentTime = myNow;

			// Render the scene according the time accumulator
			while(this._accumulator >= this._frameTime) {
				this._accumulator -= this._frameTime;
				this.update();
			}		
		}
	},

	// Executes every render tick
	update: function() {
		this._frame++;

		this._renderer.prepare();
		this._currentScene.update();
		this._renderer.camera = this._currentScene.camera;
		this._renderer.finish();

		if(this._stats) {
			this._stats.update();
		}
	},

	// Starts running the game. This function will resume the game after it is paused
	liftOff: function() {
		if(!this._currentScene) {
            throw ReferenceError("Houston, we have a problem. Required argument 'scene' is missing");
            return false;
        }

		if(!this._renderer) {
			throw ReferenceError("Houston, we have a problem. Required argument 'renderer' is missing");
			return false;
		}
		
		this._currentScene.ready();
		this._renderer.ready();

		console.info("Houston, we have a lift off!");	 

		this._paused = false;
		this.updateWithFixedTimestep();

		return true;
	},

	// Pauses the game
	land: function() {
		this._paused = true;
	},	

	crash: function() {
        if(this._crashed) {
        	throw ReferenceError("Houston, we have a problem. Unable to crash Rocket88 game");	
        	return false;
        }

		console.info("Houston, Rocket88 crashed to the ground");

		this._currentScene.dispose();
		
		AssetStore.getInstance().dispose();
		AssetLoader.getInstance().dispose();

		this._currentScene 	= null;
		this._currentTime 	= 0;
		this._frame 		= 0;
		this._paused 		= false;
		this._renderer 		= null;
		this._crashed		= true;

		return true;
	},

	// String representation of the game
	toString: function() {
		return "[" + this.type + " running=" + !this._paused + " crashed="+ this._crashed +"]";
	},
});

Director.getInstance = function() {
	var myInstance = Director.instance;
	if(myInstance==undefined) {
		myInstance = new Director(true);
	}

	return myInstance;
}

/* **********************************************
     Begin r88.renderer.js
********************************************** */

var Renderer = Class.extend({
	init: function(target) {
		if(!target) {
			throw ReferenceError("Required parameter 'target' is missing");
		}

		// Private properties
		this._target 			= target;
		this._transformMatrix 	= new Matrix();
		this._cameraMatrix 	  	= new Matrix();

		this._camera			= undefined;
		this._renderedGameObject= undefined;
		this._renderedLayer		= undefined;

		// Public properties
		this.backgroundColor 	= undefined;

		// Getters
		this.__defineGetter__("target", function() { return this._target; });
		this.__defineGetter__("transformMatrix", function() { return this._transformMatrix; });
		this.__defineGetter__("type", function() { return "renderer"; });		

		// Setters
		this.__defineSetter__("camera", function(camera) { 

			this._camera = camera;
			this._cameraMatrix = camera.transform.matrix.clone();

        	this._cameraMatrix.tx 	*= -1;
    	    this._cameraMatrix.ty 	*= -1;
		});

		this.__defineSetter__("renderedLayer", function(layer) {
			this._renderedLayer = layer;
			/*if (layer.depth!=0.0) {
				var myFocalLength = myCamera.focalLength();
				this._transform.scale = myFocalLength / (myFocalLength + this._depth);

				this._transform.x *= myScale;
				this._transform.y *= myScale;
			}*/
		});

		this.__defineSetter__("renderedGameObject", function(gameobject) {
			this._renderedGameObject = gameobject;
		});
	},

	ready: function() {
	},

	prepare: function() {
	},

	draw: function(sprite) {		
		this.calculateTransformation(sprite);
	},

	finish: function() {
	},

	calculateTransformation: function (sprite) {

		// Calculate the transform matrix
		this._transformMatrix.identity();
		
		// Add layer transformation
		this._transformMatrix.multiply(this._cameraMatrix);

		// Add game transformation
		this._transformMatrix.multiply(this._renderedGameObject.transform.matrix);

		// Add sprite transformation
		this._transformMatrix.multiply(sprite.transform.matrix);

		return this._transformMatrix;
	},

	dispose: function() {
		this._super();

		this._cameraMatrix = null;
		this._origin = null;
		this._target = null;
		this._transformMatrix = null;
	}
});

/* **********************************************
     Begin r88.scene.js
********************************************** */

var b2Vec2	= Box2D.Common.Math.b2Vec2,
	b2World	= Box2D.Dynamics.b2World;

var Scene = Object88.extend({
	// Executes when the object is instantiated
	init: function(name) {
		this._super(name);

		// Private properties        
		this._layers 		= new LinkedList();
		this._layersByName 	= new Object();
		this._gravity		= 20;

		var myGravity 		= new b2Vec2(0, this._gravity);
		this._world 		= new b2World(myGravity, true);

		this._collisionSolver = new CollisionSolver();
		this._world.SetContactListener(this._collisionSolver.listener);

		// Public properties
		this.camera 		= new Camera();

		// Getters/setters
		this.__defineGetter__("type", function() { return "scene"; });
		this.__defineGetter__("layers", function() { return this._layers.toArray(); });
		this.__defineGetter__("world", function() { return this._world; });

		this.__defineGetter__("gravity", function() { return this._layers.toArray(); });
		this.__defineGetter__("gravity", function(gravity) { 
			return this._gravity; 
		});	
	},

	// All properties are injected and set and the game is ready to run.
	ready: function() {
		this._super();

		var myNode = this._layers.head;
		while (myNode) {
			var myLayer = myNode.data;
			myLayer.ready();

			myNode = myNode.next;
		}
	},

	// Executes every render tick
	update: function() {
		this._super();

        this._collisionSolver.prepare();

		this._world.Step(1 / 60, 10, 10);
		this._world.DrawDebugData();
		this._world.ClearForces();        

		this._collisionSolver.finish();

		if(this.director.debugMode) {
			this._world.DrawDebugData();
		}

        this.camera.update();

		var myNode = this._layers.head;
		while (myNode) {
			var myLayer = myNode.data;
			myLayer.update();

			myNode = myNode.next;
		}
	},

	// Adds a layer to the scene and places it on top of the stack
	addLayer: function(layer) {	
		if(layer.isDisposed) {
			console.assert(!this.director.showErrors, "Unable to add disposed layer: " + layer.name + " to scene: " + this.name);
			return null;
		}

		// Fail if the layer doesn't have a unique name
		if(this.hasLayer(layer.name)) {
			console.assert(!this.director.showErrors, "Unable to add layer: " + layer.name + " to scene: " + this.name + " Required property 'name' must be unique");
			return null;
		}
	    
	    layer.scene = this;
		if(this.isReady) {
			layer.ready();
		}

		this._layers.add(layer);
		this._layersByName[layer.name] = layer;
        
        this.onLayerAdded(layer);

        return layer;
	},

	addLayerAbove: function(layerA, layerB) {
		if(this.hasLayer(layerB.name)) {
			console.assert(!this.director.showErrors, "Unable to add layer: " + layerA.name + " above layer: " + layerB.name + " The latter doesn't exists in scene: " + this.name);
			return false;
		}
		
		layerA.scene = this;
		if(this.isReady) {
			layerA.ready();
		}

		this._layers.insertAfter(layerA, myNode);
		this._layersByName[layerA.name] = layerA;
		
		this.onLayerAdded(layer);

		return true;
	},

	addLayerBelow: function(layerA, layerB) {
		if(this.hasLayer(layerB.name)) {
			console.assert(!this.director.showErrors, "Unable to add layer: " + layerA.name + " below layer: " + layerB.name + " The latter doesn't exists in scene: " + this.name);
			return false;
		}
		
		layerA.scene = this;
		if(this.isReady) {
			layerA.ready();
		}

		this._layers.insertBefore(layerA, myNode);
		this._layersByName[layerA.name] = layerA;
		
		this.onLayerAdded(layer);

		return true;
	},

	onLayerAdded: function(layer) {
	},

	swapLayers: function(layerA, layerB) {
		if(!this.hasLayer(layerA.name) || !this.hasLayer(layerB.name)) {
			console.assert(!this.director.showErrors, "Unable to swap layer: " + layerA.name + " with layer:" + layerB.name);
			return false;
		}
		
		var myNodeA = this._layers.nodeOf(layerA);
		var myNodeB = this._layers.nodeOf(layerB);
		this._layers.swap(myNodeA, myNodeB);
	
		return true;		
	},

	// Removes a layer from the scene
	removeLayer: function(layer) {	
		if(!this.hasLayer(layer.name)) {
			console.assert(!this.director.showErrors, "Unable to remove layer: " + layer.name + " from scene: " + this.name + " Layer doesn't exists in scene: " + this.name);
			return null;
		}

		// Remove from the scene
		this._layers.nodeOf(layer).remove();
		delete this._layersByName[layer.name];

		// Destroy layer
		if(layer.autoDispose) {
			layer.dispose();
		}

		this.onLayerRemoved(layer);

		return layer;
	},

	// Remove all layers from the scene
	removeAllLayers: function(name) {
		var myNode = this._layers.head;
		while (myNode) {

			var myLayer = myNode.data;
			this.onLayerRemoved(myLayer);

			if(myLayer.autoDispose) {
				myLayer.dispose();
			}

			var myNextNode = myNode.next;
			this._layers.remove(myNode);
			myNode = myNextNode;
		}

		this._layersByName = new Object();
	},	

	onLayerRemoved: function(layer) {
	},

	// Returns a layer by its name
	getLayerByName: function(name) {
		return this._layersByName[name];
	},

	getLayerByTag: function(tag) {
		var myNode = this._layers.head;
		while (myNode) {
			var myLayer = myNode.data;
			if(myLayer.tag!=0 && myLayer.tag==tag) {
				return myLayer;
			}

			myNode = myNode.next;
		}

		return undefined;
	},

	// Boolean indicating the scene has a layer
	hasLayer: function(name) {	
		return this._layersByName[name] != null;
	},

	clone: function(name) {
		var myScene = new Scene();
		myScene.camera = this.camera.clone();

		var i = this.layers.length;
		while(--i > -1)	{
			var myLayer = this.layers[i].clone();
			myScene.addLayer(myLayer);
		}

		return myScene;
	},
    
	dispose: function() {
		this._super();

		this._collisionSolver.dispose();
		this.removeAllLayers();

		_world.SetDestructionListener(new b2DestructionListener());

		this._collisionSolver = null;
        this._camera = null;
		this._layers = null;
		this._layersByName = null;
		this._world = null;
	},
});

/* **********************************************
     Begin r88.layer.js
********************************************** */

var Layer = Object88.extend({

	init: function(name) {	
		this._super(name);

		// Private properties	
		this._gameObjects 	 	= new LinkedList();
		this._gameObjectsByName = new Object();

		// Public properties
		this.z					= 0;
		this.scene   			= undefined;

		// Getters
		this.__defineGetter__("type", function() { return "layer"; });
		this.__defineGetter__("gameObjects", function() { return this._gameObject.toArray(); });
	},

	ready: function() {
		this._super();

		var myNode = this._gameObjects.head;
		while (myNode) {
			var myGameObject = myNode.data;
			myGameObject.ready();
			
			myNode = myNode.nextdata;
		}		
	},
	
	update: function() {
		this._super();

		var myRenderer = this.director.renderer;
		myRenderer.renderedLayer = this;
		
		var myNode = this._gameObjects.head;
		while (myNode) {
			var myGameObject = myNode.data;
			myGameObject.update();
			
			myNode = myNode.next;
		}		
	},
	
	// Adds a gameobject to the scene and places it on top of the stack
	addGameObject: function(gameobject) {	
		if(gameobject.isDisposed) {
			console.assert(!this.director.showErrors, "Unable to add disposed gameobject: " + gameobject.name + " to layer: " + this.name);
			return null;
		}

		// Fail if the gameobject doesn't have a unique name
		if(this.hasGameObject(gameobject.name)) {
			console.assert(!this.director.showErrors, "Unable to add gameobject: " + gameobject.name + " to scene: " + this.name + " Required property 'name' must be unique");
			return null;
		}
	    
	    gameobject.layer = this;
		if(this.isReady) {
			gameobject.ready();
		}

		this._gameObjects.add(gameobject);
		this._gameObjectsByName[gameobject.name] = gameobject;
        
        this.onGameObjectAdded(gameobject);

        return gameobject;
	},

	addGameObjectAbove: function(gameobjectA, gameobjectB) {
		if(this.hasGameObject(gameobjectB.name) ) {
			console.assert(!this.director.showErrors, "Unable to add gameobject: " + gameobjectA.name + " above gameobject: " + gameobjectB.name + " The latter doesn't exists in layer: " + this.name);
			return false;
		}
		
		gameobjectA.scene = this;
		if(this.isReady) {
			gameobjectA.ready();
		}

		this._gameObjects.insertAfter(gameobjectA, myNode);
		this._gameObjectsByName[gameobjectA.name] = gameobjectA;
		
        this.onGameObjectAdded(gameobject);

		return true;
	},

	addGameObjectBelow: function(gameobjectA, gameobjectB) {
		if(this.hasgameObject(gameobjectB.name)) {
			console.assert(!this.director.showErrors, "Unable to add gameobject: " + gameobjectA.name + " below gameobject: " + gameobjectB.name + " The latter doesn't exists in layer: " + this.name);
			return false;
		}
		
		gameobjectA.scene = this;
		if(this.isReady) {
			gameobjectA.ready();
		}

		this._gameObjects.insertBefore(gameobjectA, myNode);
		this._gameObjectsByName[gameobjectA.name] = gameobjectA;
		
        this.onGameObjectAdded(gameobject);

		return true;
	},

	onGameObjectAdded: function(gameobject) {
	},

	swapGameObjects: function(gameobjectA, gameobjectB) {
		if(!this.hasGameObject(gameobjectA.name) || !this.hasGameObject(gameobjectB.name)) {
			console.assert(!this.director.showErrors, "Unable to swap gameobject: " + gameobjectA.name + " with gameobject:" + gameobjectB.name);
			return false;
		}
		
		var myNodeA = this._gameObjects.nodeOf(gameobjectA);
		var myNodeB = this._gameObjects.nodeOf(gameobjectB);
		this._gameObjects.swap(myNodeA, myNodeB);
	
		return true;		
	},

	// Removes a gameobject from the scene
	removeGameObject: function(gameobject) {	
		if(!this.hasGameObject(gameobject.name)) {
			console.assert(!this.director.showErrors, "Unable to remove gameobject: " + gameobject.name + " from scene: " + this.name + " gameobject doesn't exists in layer: " + this.name);
			return null;
		}

		// Remove from the scene
		this._gameObjects.nodeOf(gameobject).remove();
		delete this._gameObjectsByName[gameobject.name];

		// Destroy gameobject
		if(gameobject.autoDispose) {
			gameobject.dispose();
		}

		this.onGameObjectRemoved(gameobject);

		return gameobject;
	},

	// Remove all gameObjects from the scene
	removeAllGameObjects: function(name) {
		var myNode = this._gameObjects.head;
		while (myNode) {

			var myGameObject = myNode.data;
			this.onGameObjectRemoved(myGameObject);

			if(myGameObject.autoDispose) {
				myGameObject.dispose();
			}

			var myNextNode = myNode.next;
			this._gameObjects.remove(myNode);
			myNode = myNextNode;
		}

		this._gameObjectsByName = new Object();
	},	

	onGameObjectRemoved: function(gameobject) {
	},

	// Returns a gameObject by its name
	getGameObjectByName: function(name) {
		return this._gameObjectsByName[name];
	},

	getGameObjectByTag: function(tag) {
		var myNode = this._gameObjects.head;
		while (myNode) {
			var myGameObject = myNode.data;
			if(myGameObject.tag!=0 && myGameObject.tag==tag) {
				return myGameObject;
			}

			myNode = myNode.next;
		}

		return undefined;
	},

	// Boolean indicating the scene has a gameObject
	hasGameObject: function(name) {	
		return this._gameObjectsByName[name] != null;
	},

	clone: function(name) {
		var myLayer = new Layer(name);
		myLayer.depth = this.depth;

		var i = this.gameobjects.length;
		while(--i > -1)	{
			var myObject = this._gameObjects[i].clone();
			myLayer.addGameObject(myObject);
		}

		return myLayer;
	},

	// inheritDoc
	dispose: function() {
		this._super();	
		this.removeAllGameObjects();
					
		this._gameObjects = null;
		this._gameObjectsByName = null;		
		this._renderer = null;
	}
});

/* **********************************************
     Begin r88.game.object.js
********************************************** */

var GameObject = Object88.extend({
	// inheritDoc
	init: function(name) {
		this._super(name);

		// Private properties
		this._components 		= new LinkedList();
		this._componentsByName 	= new Object();		

		this._transform			= new TransformComponent();
		this._transform.gameobject = this;

		this._graphic			 = new GraphicComponent();
		this._graphic.gameobject = this;

		// Public properties
		this.layer 				= undefined;
		this.group				= undefined;

		// Getters
		this.__defineGetter__("type", function() { return "gameobject"; });
		this.__defineGetter__("components", function() { return this._components.toArray(); });
		this.__defineGetter__("transform", function() { return this._transform; });
		this.__defineGetter__("graphic", function() { return this._graphic; });	
	},
			
	// inheritDoc
	ready: function() {
		this._super();
		
		var myNode = this._components.head;
		while (myNode) {
			var myComponent = myNode.data;
			myComponent.ready();
			
			myNode = myNode.next;
		}	

		this._transform.ready();
		this._graphic.ready();
	},
	
	// inheritDoc
	update: function() {
		this._super();
	
		// Set the current gameobject of the renderer
		var myRenderer = this.director.renderer;
		myRenderer.renderedGameObject = this;
				
		// Update all attached components
		var myNode = this._components.head;
		while (myNode) {
			var myComponent = myNode.data;
			if(myComponent.enabled) {
				myComponent.update();
			}
			
			myNode = myNode.next;
		}		

		this._transform.update();
		this._graphic.update();
	},

	
	// Adds an component to the gameobject
	addComponent: function(component) {
		if(component.isDisposed) {
			console.assert(!this.director.showErrors, "Unable to add disposed component: " + component.name + " to gameobject: " + this.name);
			return null;
		}

		if(this.hasComponent(component.name)) {
			console.assert(!this.director.showErrors, "Unable to add component: " + component.name + " to gameobject: " + this.name + " Required property 'name' must be unique");
			return null;
		}

		component.gameobject = this;
		if(this.isReady) {
			component.ready();
		}	

		// Add components and notify listeners
		this._components.add(component);
		this._componentsByName[component.name] = component;
				
		this.onComponentAdded(component);

		return component;
	},
	
	onComponentAdded: function(component) {
	},

	// Removes an component from the GameObject
	removeComponent: function(component) {
		if(!this.hasComponent(component.name)) {
			return false;
		}
		
		this._objectList.nodeOf(component).remove();
		delete this._objectSet[component.name];
		
		if(myComponent.autoDispose) {
			myComponent.dispose();
		}

		this.onComponentRemoved(component);
				
		return myObject;	
	},
	
	// Removes all components from the GameObject
	removeAllComponents: function() {
		var myNode = this._components.head;
		while (myNode) {

			var myComponent = myNode.data;
			this.onComponentRemoved(myComponent);

			// Destroy the component
			if(myComponent.autoDispose) {
				myComponent.dispose();
			}
			
			myNode = myNode.next;
		}
		
		this._components = new LinkedList();
		this._componentsByName = new Object();	
	},

	onComponentRemoved: function(component) {
	},
				
	// Boolean indicating the component has a gameobject
	hasComponent: function(name) {
		return this._componentsByName[name]!=null;
	},
		
	// Returns a gameobject by its name	
	getComponentByName: function(name) {
		return this._componentsByName[name];
	},

	getComponentByTag: function(tag) {
		var myNode = this._layers.head;
		while (myNode) {
			var myComponent = myNode.data;
			if(myComponent.tag!=0 && myComponent.tag==tag) {
				return myComponent;
			}

			myNode = myNode.next;
		}

		return undefined;
	},

	clone: function(name) {
		var myGameObject = new Layer(name);

		var i = this._components.length;
		while(--i > -1)	{
			var myComponent = this._components[i].clone();
			myGameObject.addComponent(myComponent);
		}

		return myGameObject;
	},	
	
	// inheritDoc
	dispose: function() {
		this._super();

		this._graphic.dispose();
		this._transform.dispose();
		this.removeAllComponents();

		this._components = null;
		this._componentsByName = null;
		this._graphic = null;
		this._transform = null;
		this._renderer = null;

		this.layer = null;
	}
});

/* **********************************************
     Begin r88.component.js
********************************************** */

var Component = Object88.extend({

	init: function(name) {
		this._super(name);
		
		// Private properties
		this._enabled 	= true;

		// Public properties
		this.gameobject = undefined;

		// Getters
		this.__defineGetter__("type", function() { return "component"; });
		this.__defineGetter__("enabled", function() { return this._enabled; });
	},
	
	ready: function() {
	},

	enable: function () {
		this._enabled = true;
	},

	disable: function () {
		this._enabled = false;
	},

	dispose: function() {
		this._super();
		this.gameObject = null;
	}
});

/* **********************************************
     Begin r88.camera.js
********************************************** */

var Camera = Object88.extend({

    // Executes when the object is instantiated
    init: function(name)
    {
        this._super(name);

        // Private properties
        this._transform  = new TransformComponent();

        // Public properties
        this.isStatic    = true;
        this.focalLength = 80;
        this.viewport    = new Rectangle();

        // Getters
        this.__defineGetter__("type", function() { return "camera"; });
        this.__defineGetter__("transform", function() { return this._transform; });
    },


    clone: function(name) {
        var myCamera = new Camera(name);
        myCamera.isStatic    = this.isStatic;
        myCamera.focalLength = this.focalLength;
        myCamera.viewport    = this.viewport.clone();
        myCamera.transform   = this._transform.clone();

        return myCamera;
    },

    
    dispose: function() {
        this._super();

        this.transform = null;
        this.viewport = null;
    },
});

/* **********************************************
     Begin r88.canvas.renderer.js
********************************************** */

var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

var CanvasRenderer = Renderer.extend({

	init: function(target) {
		this._super(target);

		if(target.tagName.toLowerCase()!="canvas") {
			throw ReferenceError("Required property 'target' must be a canvas object");
		}

		// Private properties
		this._context = target.getContext("2d");

		// Getters
		this.__defineGetter__("context", function() { return this._context; });		
	},

	ready: function() {
		this._super();
		
		// Setup debug drawing
		var myDirector = Director.getInstance();
		if(myDirector.debugMode) {
			this.backgroundColor = "#cccccc";

			var myDebugDraw = new b2DebugDraw();
			myDebugDraw.SetSprite(this._context);
			myDebugDraw.SetDrawScale(30);
			myDebugDraw.SetFillAlpha(1.0);
			myDebugDraw.SetLineThickness(1.0);
			myDebugDraw.SetFlags(b2DebugDraw.e_shapeBit|b2DebugDraw.e_jointBit);
			
			var myDirector = Director.getInstance();
			myDirector.scene.world.SetDebugDraw(myDebugDraw);		
		}
	},

	prepare: function() {
		this._super();

        // Set the backgroundColor
		if (this.backgroundColor) {

			this._context.fillStyle = "#cccccc";
			this._context.fillRect(0, 0, this._target.width, this._target.height);
		}
		else {
			this._context.clearRect(0, 0, this._target.width, this._target.height);
		}
	},

	// Draws a sprite to the renderer
	draw: function(sprite) {
		this._super(sprite);

		var myDirector = Director.getInstance();
		var myAssetStore = AssetStore.getInstance();

		if(!myAssetStore.hasAsset(sprite.url)) {
			console.assert(!myDirector.showErrors, "Unable to find sprite:" + sprite.url + " at the AssetStore");
			return;
		}

		// Save context
		this._context.save();		

		var myWidth 	= sprite.cropRect.size.width;
		var myHeight 	= sprite.cropRect.size.height;
		var myLeft 		= -myWidth >> 1;
		var myTop 		= -myHeight >> 1;

		// Transform canvas context
		this._context.transform(
			this.transformMatrix.a, 
			this.transformMatrix.b, 
			this.transformMatrix.c, 
			this.transformMatrix.d, 
			this.transformMatrix.tx, 
			this.transformMatrix.ty);
		
		this._context.globalAlpha = sprite.alpha;

		var myImage = myAssetStore.assetForPath(sprite.url);
		this._context.drawImage(
			myImage, 		
		
			// Source
			sprite.cropRect.origin.x, sprite.cropRect.origin.y, 
			myWidth, myHeight,

			// Destination
			myLeft, myTop, 
			myWidth, myHeight);

		// Restore the context to its original state
    	this._context.restore();
	}
});

/* **********************************************
     Begin r88.html.renderer.js
********************************************** */

var HTMLRenderer = Renderer.extend({
	init: function(target) {
		this._super(target);

		if(target.tagName.toLowerCase()!="div") {
			throw new ReferenceError("Required property 'target' must be a div object");
		}
	},

	prepare: function() {
		this._target.style.position = "relative";
		this._htmlString = "";
	},

	draw: function(sprite) {
		this._super(sprite);
		
		var myWidth 	= sprite.cropRect.size.width;
		var myHeight 	= sprite.cropRect.size.height;
		var myLeft 		= -myWidth >> 1;
		var myTop 		= -myHeight >> 1;

		var myCss = "";
		myCss += "position:absolute;";
		myCss += "left:" + myLeft + "px;top:" + myTop + "px;";
		myCss += "width:" + myWidth + "px;height:" + myHeight + "px;";
		myCss += "background-image:url(" + sprite.url + ");";
		myCss += "background-position:" + -1 * sprite.cropRect.origin.x + "px " + -1 * sprite.cropRect.origin.y + "px;";
		myCss += this.transformMatrix.toCss();
		myCss += sprite.toCss();

		this._htmlString += "<div id=" + this._renderedGameObject.name + " style='" + myCss + "'></div>";			
	},

	finish: function() {
		this.target.innerHTML = this._htmlString;
	}
});

/* **********************************************
     Begin r88.physics.object.js
********************************************** */

var PhysicsObject = GameObject.extend({
	
	init: function(name) {
		this._super(name);

		// Private properties
		this._reusableVector = new b2Vec2();

		this._physics = new PhysicsComponent();
		this._physics.gameobject = this;

		this._collision = new CollisionComponent();
		this._collision.gameobject = this;

		// Getters
		this.__defineGetter__("physics", function() { return this._physics; });	
		this.__defineGetter__("collision", function() { return this._collision; });	

		// Handlers
		this.transform.onTransform = delegate(this, this.onTransform);
	},

	ready: function() {
		this._super();

		this._physics.ready();
		this._collision.ready();		
	},

	update: function() {
		this._super();

		var myPosition = this._physics.body.GetPosition();
		this._transform.position.x = myPosition.x * 30;
		this._transform.position.y = myPosition.y * 30;			

		this._transform.rotation.radians = this._physics.body.GetAngle();
	},

	onTransform: function(property, newValue, oldValue) {
		var myScale = 1 / 30;

		this._reusableVector.x = this.transform.position.x * myScale;
		this._reusableVector.y = this.transform.position.y * myScale;

		var myRotation = this.transform.rotation.radians;
		this._physics.body.SetPositionAndAngle(this._reusableVector, myRotation); 
	}
});

/* **********************************************
     Begin r88.interactive.object.js
********************************************** */

var InteractiveObject = PhysicsObject.extend({

	init: function(name) {
		this._super(name);

		// Private properties
		this._keys = new KeysComponent();
		this.addComponent(this._keys);		

		// Getters
		this.__defineGetter__("keys", function() { return this._keys; });	
	}
});

/* **********************************************
     Begin r88.transform.component.js
********************************************** */

 var TransformComponent = Component.extend({

	init: function() {
		this._super("transform");		

		// Public properties
		this.origin 	= new Point(0, 0);		
		this.scaleX		= 0;
		this.scaleY		= 0;

		// Private properties	
		this._scale		= 1.0;
		this._flippedX 	= false;
		this._flippedY 	= false;
		this._position	= new Point();
		this._rotation	= new Rotation();	
		this._matrix 	= new Matrix();

		// Getters/setters				
		this.__defineGetter__("degrees", function() { return this._rotation.degrees; });
		this.__defineSetter__("degrees", function(degrees) { 
			var myOldValue = this._rotation;
			this._rotation.degrees = degrees;		

			this.onTransform("rotation", this._rotation, myOldValue);
		});

		this.__defineGetter__("radians", function() { return this._rotation.radians; });
		this.__defineSetter__("radians", function(radians) { 
			var myOldValue = this._rotation;
			this._rotation.radians = radians;
			
			this.onTransform("rotation", this._rotation, myOldValue);
		});

		this.__defineGetter__("x", function() { return this._position.x });
		this.__defineSetter__("x", function(x) { 
			var myOldValue = this._position.x;
			this._position.x = x;
			
			this.onTransform("position", this._position, myOldValue);
		});

		this.__defineGetter__("y", function() { return this._position.y });
		this.__defineSetter__("y", function(y) { 
			var myOldValue = this._position.y;
			this._position.y = y;

			this.onTransform("position", this._position, myOldValue);
		})

		this.__defineGetter__("scale", function() { return this._scale });
		this.__defineSetter__("scale", function(scale) { 
			this._scale = scale;
			this.scaleX = scale;
			this.scaleY = scale;
		});

		this.__defineGetter__("position", function() { return this._position });
		this.__defineGetter__("rotation", function() { return this._rotation; });

		this.__defineGetter__("matrix", function() {
			var myFlipX = this._flippedX ? -1 : 1,
				myFlipY = this._flippedY ? -1 : 1;

			this._matrix.identity();
			this._matrix.translate(this._position.x, this._position.y);
			this._matrix.rotate(this._rotation.radians);

			this._matrix.scale(this.scaleX, this.scaleY);
			this._matrix.scale(myFlipX, myFlipY);
			this._matrix.translate(-1 * this.origin.x, -1 *this.origin.y);

			return this._matrix;
		});
	},

	flipX: function() {
		this._flippedX = !this._flippedX;
	},

	flipY: function() {
		this._flippedY = !this._flippedY;
	},

	onTransform: function(property, oldValue, newValue) {
	}	
});



/* **********************************************
     Begin r88.graphic.component.js
********************************************** */

 var GraphicComponent = Component.extend({

	init: function() {
		this._super("graphic");
	
		// Private properties
		this._sprite 		= undefined;	

		// Getters/setters
		this.__defineGetter__("renderer", function() { return this._renderer });
		this.__defineGetter__("sprite", function() { return this._sprite });
		this.__defineSetter__("sprite", function(sprite) { 
			if(this._sprite) {
				console.warn ("Replacing sprite: " + this._sprite.name + " with sprite: " + sprite.name)

				if(this._sprite.autoDispose) {
					this._sprite.dispose();
				}
			}

			this._sprite = sprite 
		});
	},
	
	update: function() {
		this._super();	

		if(this._sprite) {
			this._sprite.update();

			var myRenderer = Director.getInstance().renderer;
			myRenderer.draw(this._sprite);			
		}	
	},

	dispose: function() {
		this._super();
		this._sprite.dispose();
		this._sprite = null;
	}
});

/* **********************************************
     Begin r88.physics.component.js
********************************************** */

var b2Vec2 			= Box2D.Common.Math.b2Vec2,
	b2FixtureDef 	= Box2D.Dynamics.b2FixtureDef,
	b2PolygonShape 	= Box2D.Collision.Shapes.b2PolygonShape,
	b2CircleShape 	= Box2D.Collision.Shapes.b2CircleShape,
	b2Body 			= Box2D.Dynamics.b2Body,
	b2BodyDef 		= Box2D.Dynamics.b2BodyDef;

var PhysicsComponent = Component.extend({

	init: function() {
		this._super("physics");		

		// Private properties
		this._body 			= undefined;
		this._reusableVector= new b2Vec2();

		this._damping 		= 0.35;
		this._density 		= 1.0;
		this._friction 		= 0.5;
		this._restitution 	= 0.35;	

		// Public properties
		this.isPlatform		= false;

		// Getters/setters
		this.__defineGetter__("body", function() { return this._body; });

		this.__defineGetter__("isStatic", function() { return this.body.GetType()==b2Body.b2_staticBody; });
		this.__defineSetter__("isStatic", function(isStatic) { 
			this.setType(isStatic ? "static" : "dynamic");
		});

		this.__defineGetter__("isKinematic", function() { return this.body.GetType()==b2Body.b2_kinematicBody; });
		this.__defineSetter__("isKinematic", function(isKinematic) { 
			this.setType(isKinematic ? "kinematic" : "dynamic");
		});

		this.__defineGetter__("isBullet", function() { return this.body.IsBullet(); });
		this.__defineSetter__("isBullet", function(isBullet) { 
			this.SetBullet(isBullet);
		});

		this.__defineGetter__("isFixedRotation", function() { return this.body.IsFixedRotation(); });
		this.__defineSetter__("isFixedRotation", function(isFixedRotation) { 
			this.SetFixedRotation(isFixedRotation);
		});

		this.__defineGetter__("isTrigger", function() { return this.body.GetFixtureList().IsSensor(); });
		this.__defineSetter__("isTrigger", function(isTrigger) { 
			this._body.GetFixtureList().SetSensor(isTrigger);
		});
	},

	ready: function() {
		this._super();
	
		// Create body definition
		var myBody 			  = new b2BodyDef();
		myBody.userData 	  = this.gameobject;
		myBody.bullet 		  = false;
		myBody.fixedRotation  = false;

		var myScale = 1 / 30;
		myBody.position.x 	  = this.gameobject.transform.position.x * myScale;
		myBody.position.y 	  = this.gameobject.transform.position.y * myScale;
		myBody.angle 		  = this.gameobject.transform.rotation.radians;

		myBody.angularDamping = this._damping;
		myBody.linearDamping  = this._damping;
		myBody.type 		  = b2Body.b2_dynamicBody;	

		// Create body
		this._body = this.director.scene.world.CreateBody(myBody);
	},

	addCircle: function(radius) {
		var myScale  = 1 / 30,
			myRadius = radius * myScale,
			myShape  = new b2CircleShape(radius * myScale);

		this.createFixture(myShape);
	},

	addBox: function(size) {
		var myScale 	= 1 / 30,
     		myWidth 	= size.width >> 1,
     		myHeight 	= size.height >> 1,
       		myShape = new b2PolygonShape();

       	myShape.SetAsBox(myWidth * myScale, myHeight * myScale);
		this.createFixture(myShape);
	},

	addPolygon: function() {
	},

	createFixture: function(shape) {
    	var myFixture 		  = new b2FixtureDef();
		myFixture.userData 	  = this.gameobject;
		myFixture.shape 	  = shape;

		myFixture.density 	  = this._density;
		myFixture.friction 	  = this._friction;
		myFixture.restitution = this._restitution;
		myFixture.isSensor 	  = this._isTrigger;

    	this._body.CreateFixture(myFixture);
	},	

	setType: function(type) {
		var myIsKinematic 	= type=="kinematic",
			myIsStatic 		= type=="static";

		this._body.SetType(b2Body.b2_dynamicBody);
		if (myIsKinematic) {
			this._body.SetType(b2Body.b2_kinematicBody);
		} 
		else if(myIsStatic) {
			this._body.SetType(b2Body.b2_staticBody);	
		}		
	},

	applyForce: function(x, y) {
		if (this.isReady) {
			this._reusableVector.x = x;
			this._reusableVector.y = y;

			this._body.ApplyForce(this._reusableVector, this._body.GetPosition());
		}
	},

	applyImpulse: function(x, y) {
		if (this.isReady) {
			this._reusableVector.x = x;
			this._reusableVector.y = y;

			this._body.ApplyImpulse(this._reusableVector, this._body.GetPosition());
		}
	},

	applyTorque: function(torque) {
		if (this.isReady) {
			this._body.ApplyTorque(torque);
		}
	},
});

/* **********************************************
     Begin r88.collision.component.js
********************************************** */

 var CollisionComponent = Component.extend({

	init: function() {
		this._super("collision");

		this._contacts = "";
		this._groups = "";
	},

	beginContact: function(gameobject) {
		this._contacts += "|" + gameobject.name; 
		if(gameobject.group) {
			this._groups += "|" + gameobject.group;
		}
	},

	endContact: function(gameobject) {
		this._contacts = this._contacts.replace("|" + gameobject.name, ""); 
		if(gameobject.group) {
			this._groups = this._groups.replace("|" + gameobject.group, ""); 
		}
	},

	onCollision: function(gameobject, position, impact) {
	},

	touches: function(name) {
		return this._contacts.indexOf(name) > -1;
	},

	touchesGroup: function(name) {
		return this._groups.indexOf(name) > -1;
	},

	dispose: function() {
		this._super();
		this._contacts = null;
	}
});

/* **********************************************
     Begin r88.keys.component.js
********************************************** */

 var KeysComponent = Component.extend({

	init: function() {
		this._super("keys");

		this.pressedKeys = "";

		document.onkeydown = delegate(this, function(event) {

			if(this.enabled) {
				var myCode = event.keyCode;

				if(!this.keyIsDown(myCode)) {
					this.pressedKeys += "|" + myCode;
					
					this.onKeyDown(myCode);

					switch(myCode) {
						case 37: this.onLeftArrow("down"); break;
						case 39: this.onRightArrow("down"); break;
						case 37: this.onUpArrow("down"); break;
						case 40: this.onDownArrow("down"); break;
						case 32: this.onSpacebar("down"); break;
					}					
				}
			}
		});

		document.onkeyup = delegate(this, function(event) {

			if(this.enabled) {
				var myCode = event.keyCode;

				if(this.keyIsDown(myCode)) {
					this.pressedKeys = this.pressedKeys.replace("|" + myCode, "");

					if(this.enabled) {
						this.onKeyUp(event.keyCode);
						
						switch(event.keyCode) {
							case 37: this.onLeftArrow("up"); break;
							case 39: this.onRightArrow("up"); break;
							case 37: this.onUpArrow("up"); break;
							case 40: this.onDownArrow("up"); break;
							case 32: this.onSpacebar("up"); break;
						}				
					}
				}				
			}
		});
	},

	keyIsDown: function(code) {
		return this.pressedKeys.indexOf("|" + code) > -1;
	},

	onKeyDown: function(keyCode) {
	},

	onKeyUp: function(keyCode) {
	},

	onLeftArrow: function(direction) {
	},

	onRightArrow: function(direction) {
	},

	onUpArrow: function(direction) {
	},

	onDownArrow: function(direction) {
	},

	onSpacebar: function(direction) {
	}
});

/* **********************************************
     Begin r88.sprite.js
********************************************** */

var Sprite = Class.extend({

	// inheritDoc
	init: function(url, spritesheet) {

		if(!url) {
			console.assert(!Rocket88.showErrors, "Required argument 'url' is missing");
			return;
		}

		// Private properties
		this._currentFrame	= undefined;
		this._disposed 		= false;
		this._spritesheet	= spritesheet;
		this._url	 		= url;

		//this._bounds		= new Rectangle;
		this._size			= new Size();
		this._transform		= new TransformComponent();

		// Public properties
		this.cropRect 		= undefined;
		this.className		= undefined;
		this.alpha			= 1.0;	
		this.tiled 			= false;

		// Getters/Setters
		this.__defineGetter__("currentFrame", function() { return this._currentFrame; });
		this.__defineGetter__("disposed", function() { return this._disposed; });
		this.__defineGetter__("spritesheet", function() { return this._spritesheet; });
		this.__defineGetter__("size", function() { return this._size; });
		this.__defineGetter__("transform", function() { return this._transform; });
		this.__defineGetter__("url", function() { return this._url; });

		if(this._spritesheet) {
			this._size = this._spritesheet.firstFrame.size.clone();
			this.cropRect = this._spritesheet.firstFrame.clone();
		}
	},
	
	update: function() {

	},
	
	showFrame: function(name) {
		if(!this._spritesheet && Rocket88.showWarnings) {
			console.error("Unable to set frame on sprite: " + this._url + " Sprite doesn't have spritesheet");
		}

		var myFrame = this._spritesheet.frameByName(name);
		this.cropRect = myFrame.clone();
	},

	toCss: function() {
		return "-moz-opacity:" + this.alpha + ";-webkit-opacity:" + this.alpha + ";-o-opacity:" + this.alpha + ";opacity:" + this.alpha + ";";
	},

	dispose: function () {
        if(this._disposed && Rocket88.showErrors) {
        	console.error("Unable to dispose object: " + this.name);	
        }

		console.info("sprite: " + this._url + " is disposed");	

		this._disposed = true;
		this._url = null;
		this._size = null;
		this._spritesheet = null;
		this._transform = null;

		this.className = null;
		this.cropRect = null;
	}
});

/* **********************************************
     Begin r88.animated.sprite.js
********************************************** */

/**
 * @author patrickpietens
 *
 */
 
var AnimatedSprite = Sprite.extend({

	// inheritDoc
	init: function(url, spritesheet)
	{
		this._super(url, spritesheet);

		if(!spritesheet) {
			console.assert(!Rocket88.showErrors, "Required argument 'spritesheet' is missing");
			return;
		}

		this._super(url, spritesheet);

		// Private properties
		this._currentAnimation	= undefined;
		this._running			= false;

		// Public properties
		this.loop 				= true;
		this.reverse 			= false;

		// Getters
		this.__defineGetter__("currentAnimation", function() { return this._currentAnimation; });
		this.__defineGetter__("isRunning", function() { return this._running; });
	},
		
	update: function() {
		this._super();

		var self = this;

		if(this._running && this._spritesheet) {
			if(this._reversed) {
				prevFrame();
			}
			else {
				nextFrame();
			}

			this.showFrame(this._currentFrame.data);			
		}

		function nextFrame() {
			if(self._currentFrame.next) {
				self._currentFrame = self._currentFrame.next;
			}
			else if(self.loop) {
				self._currentFrame = self._currentAnimation.head;	
			}
		}

		function prevFrame() {
			if(self._currentFrame.prev) {
				self._currentFrame = self._currentFrame.prev;
			}
			else if(self.loop) {
				self._currentFrame = self._currentAnimation.tail;	
			}
		}	
	},

	play: function(animation) {
		this._running = true;

		this._currentAnimation 	= this.spritesheet.animationByName(animation);		
		if(this._reversed) {
			this._currentFrame	= this._currentAnimation.tail;	
		}
		else {
			this._currentFrame	= this._currentAnimation.head;
		}

		this.showFrame(this._currentFrame.data);

		return this;
	},

	stop: function() {
		this._running	= false;
		return this;
	},

	dispose: function() {
		this._super();

		this._currentAnimation = null;
	}
});

/* **********************************************
     Begin r88.spritesheet.js
********************************************** */

var Spritesheet = Class.extend({

	// inheritDoc
	init: function(data) {
		if(!data) {
			console.assert(!Rocket88.showErrors, "Required argument 'data' is missing");
			return;
		}

		// Private properties
		this._rawData 		= data;
		this._disposed		= false;
		this._firstFrame 	= undefined;
		this._animations 	= new Object()
		this._frames 		= new Object();

		// Getters
		this.__defineGetter__("isDisposed", function () { return this._disposed });
		this.__defineGetter__("rawData", function () { return this._rawData });
		this.__defineGetter__("frames", function () { return this._frames });
		this.__defineGetter__("firstFrame", function () { return this._firstFrame });
		this.__defineGetter__("animations", function () { 
			var myNames = new Array();
			for (var name in this._animations) {
				myNames.push(name);
			}

			return myNames;
		});

		var self = this;

		// Private functions
		function parseData() {
			for (var name in data.frames)		
			{
				var myFrame = data.frames[name].frame;

				var myRect = new Rectangle(myFrame.x, myFrame.y, myFrame.w, myFrame.h);
				addFrame(name, myRect);
			}			
		}

		function addFrame(name, frame) {
			self._frames[name] = frame;

			if(!self._firstFrame) {
				self._firstFrame = frame;
			}

			var myRegExp = /(-|_)*(\d+)(\.[a-zA-Z]{3,4})$/;
			var myName = name.replace(myRegExp, "");

			if(!self._animations[myName]) {
				self._animations[myName] = new LinkedList();
			}

			self._animations[myName].add(name);
		}

		parseData();
	},

	hasAnimation: function(name) {
		return this._animations[name] != null;
	},

	animationByName: function(name) {
		return this._animations[name];
	},

	hasFrame: function(name) {
		return this._frames[name] != null;
	},

	frameByName: function(name) {
		return this._frames[name];
	},

	dispose: function() {
        if(this._disposed && Rocket88.showErrors) {
        	console.error("Unable to dispose object: " + this.name);	
        }

		console.info(this.type + ": " + this._name + " is disposed");	
		
		this._rawData = null;
		this._firstFrame = null;			
		this._animations = null;
		this._frames = null;
	}
});

/* **********************************************
     Begin r88.game.object.js
********************************************** */

var GameObject = Object88.extend({
	// inheritDoc
	init: function(name) {
		this._super(name);

		// Private properties
		this._components 		= new LinkedList();
		this._componentsByName 	= new Object();		

		this._transform			= new TransformComponent();
		this._transform.gameobject = this;

		this._graphic			 = new GraphicComponent();
		this._graphic.gameobject = this;

		// Public properties
		this.layer 				= undefined;
		this.group				= undefined;

		// Getters
		this.__defineGetter__("type", function() { return "gameobject"; });
		this.__defineGetter__("components", function() { return this._components.toArray(); });
		this.__defineGetter__("transform", function() { return this._transform; });
		this.__defineGetter__("graphic", function() { return this._graphic; });	
	},
			
	// inheritDoc
	ready: function() {
		this._super();
		
		var myNode = this._components.head;
		while (myNode) {
			var myComponent = myNode.data;
			myComponent.ready();
			
			myNode = myNode.next;
		}	

		this._transform.ready();
		this._graphic.ready();
	},
	
	// inheritDoc
	update: function() {
		this._super();
	
		// Set the current gameobject of the renderer
		var myRenderer = this.director.renderer;
		myRenderer.renderedGameObject = this;
				
		// Update all attached components
		var myNode = this._components.head;
		while (myNode) {
			var myComponent = myNode.data;
			if(myComponent.enabled) {
				myComponent.update();
			}
			
			myNode = myNode.next;
		}		

		this._transform.update();
		this._graphic.update();
	},

	
	// Adds an component to the gameobject
	addComponent: function(component) {
		if(component.isDisposed) {
			console.assert(!this.director.showErrors, "Unable to add disposed component: " + component.name + " to gameobject: " + this.name);
			return null;
		}

		if(this.hasComponent(component.name)) {
			console.assert(!this.director.showErrors, "Unable to add component: " + component.name + " to gameobject: " + this.name + " Required property 'name' must be unique");
			return null;
		}

		component.gameobject = this;
		if(this.isReady) {
			component.ready();
		}	

		// Add components and notify listeners
		this._components.add(component);
		this._componentsByName[component.name] = component;
				
		this.onComponentAdded(component);

		return component;
	},
	
	onComponentAdded: function(component) {
	},

	// Removes an component from the GameObject
	removeComponent: function(component) {
		if(!this.hasComponent(component.name)) {
			return false;
		}
		
		this._objectList.nodeOf(component).remove();
		delete this._objectSet[component.name];
		
		if(myComponent.autoDispose) {
			myComponent.dispose();
		}

		this.onComponentRemoved(component);
				
		return myObject;	
	},
	
	// Removes all components from the GameObject
	removeAllComponents: function() {
		var myNode = this._components.head;
		while (myNode) {

			var myComponent = myNode.data;
			this.onComponentRemoved(myComponent);

			// Destroy the component
			if(myComponent.autoDispose) {
				myComponent.dispose();
			}
			
			myNode = myNode.next;
		}
		
		this._components = new LinkedList();
		this._componentsByName = new Object();	
	},

	onComponentRemoved: function(component) {
	},
				
	// Boolean indicating the component has a gameobject
	hasComponent: function(name) {
		return this._componentsByName[name]!=null;
	},
		
	// Returns a gameobject by its name	
	getComponentByName: function(name) {
		return this._componentsByName[name];
	},

	getComponentByTag: function(tag) {
		var myNode = this._layers.head;
		while (myNode) {
			var myComponent = myNode.data;
			if(myComponent.tag!=0 && myComponent.tag==tag) {
				return myComponent;
			}

			myNode = myNode.next;
		}

		return undefined;
	},

	clone: function(name) {
		var myGameObject = new Layer(name);

		var i = this._components.length;
		while(--i > -1)	{
			var myComponent = this._components[i].clone();
			myGameObject.addComponent(myComponent);
		}

		return myGameObject;
	},	
	
	// inheritDoc
	dispose: function() {
		this._super();

		this._graphic.dispose();
		this._transform.dispose();
		this.removeAllComponents();

		this._components = null;
		this._componentsByName = null;
		this._graphic = null;
		this._transform = null;
		this._renderer = null;

		this.layer = null;
	}
});

/* **********************************************
     Begin eightyeight.js
********************************************** */

/*
@codekit-prepend "rocket88/utils/r88.utils.js"
@codekit-prepend "rocket88/utils/r88.event.dispatcher.js"	
@codekit-prepend "rocket88/utils/r88.linked.list.js"
@codekit-prepend "rocket88/utils/r88.object.pool.js"
@codekit-prepend "rocket88/utils/r88.asset.loader.js"
@codekit-prepend "rocket88/utils/r88.asset.store.js"
@codekit-prepend "rocket88/utils/r88.collision.solver.js"

@codekit-prepend "rocket88/utils/geom/r88.matrix.js"
@codekit-prepend "rocket88/utils/geom/r88.point.js"
@codekit-prepend "rocket88/utils/geom/r88.rectangle.js"
@codekit-prepend "rocket88/utils/geom/r88.size.js"
@codekit-prepend "rocket88/utils/geom/r88.rotation.js"

@codekit-prepend "rocket88/r88.object88.js"
@codekit-prepend "rocket88/r88.director.js"
@codekit-prepend "rocket88/r88.renderer.js"

@codekit-prepend "rocket88/r88.scene.js"
@codekit-prepend "rocket88/r88.layer.js"
@codekit-prepend "rocket88/r88.game.object.js"
@codekit-prepend "rocket88/r88.component.js";
@codekit-prepend "rocket88/r88.camera.js"

@codekit-prepend "rocket88/renderers/r88.canvas.renderer.js"
@codekit-prepend "rocket88/renderers/r88.html.renderer.js"

@codekit-prepend "rocket88/gameobjects/r88.physics.object.js"
@codekit-prepend "rocket88/gameobjects/r88.interactive.object.js"

@codekit-prepend "rocket88/components/r88.transform.component.js";
@codekit-prepend "rocket88/components/r88.graphic.component.js";
@codekit-prepend "rocket88/components/r88.physics.component.js";
@codekit-prepend "rocket88/components/r88.collision.component.js";
@codekit-prepend "rocket88/components/r88.keys.component.js";

@codekit-prepend "rocket88/graphics/r88.sprite.js"
@codekit-prepend "rocket88/graphics/r88.animated.sprite.js"
@codekit-prepend "rocket88/graphics/r88.spritesheet.js"
*/